### 汉诺塔统计次数问题
```sh
def hanoi(n,step):
    if n == 1:
        step +=1
        return step
    else:
        hanoi(n-1,step)
        #print('需要%d步' % step)
        step +=1
        hanoi(n-1,step)


n = int(input('层数是：'))
step = 0
step = int(hanoi(n,step))
print('需要%d步' % step)
```
上面的step变量是无法实现统计需要移动的次数的，和C++不同，python变量的作用域是局限在函数内部的，就算是在hanoi函数给step赋值，但是在hanoi函数内部，也只是一个与step相同名字的标签而已，并没有真正的改变step的值，解决如下：
```sh
step=0
def hanoi(n):
    global step
    if n == 1:
        step+=1
    else:
        hanoi(n-1)
        step += 1
        hanoi(n-1)

n = int(input('层数是：'))
hanoi(n)
print('需要%d步' % step)
```

### 函数
1.自定义函数语法： def 函数名（参数1，参数2，...）：    
2.函数文档：在自定义函数内部，用‘’(单引号)引起来的一段话，类似于注释。使用方法：函数名__doc__或者help（函数名），就可以看到函数文档了。函数文档比较长，可以对函数的功能、参数等方面进行详细的解释。    
3.关键字参数：在函数调用时：多个参数之间会有顺序问题，使用关键字参数，就可以避免因为参数顺序错误带来的程序错误，使用方法：函数名(关键字=参数1，关键字=参数2,...)    
4.默认参数：在自定义函数时，可以对形参赋初值，使用方法：def 函数名（参数1=初值）：    
5.收集参数：可以是自定义函数传入多个不定量的参数，使用方法：def 函数名（*参数）：。注意：当既有收集参数和其他参数时，应对其他参数赋初值    
6.闭包：如果在一个内部函数里，对在外部作用域的变量进行引用，则称内部函数为闭包    
```sh
def FunX(x):
    def FunY(y):
        return x*y
    return FunY
```
FunY就是闭包

### 变量的作用域
1.函数变量的作用域：！！！！！在函数内部修改全局变量，python有屏蔽机制，会新建一个同名的局部变量来代替这个全局变量，而原来的全局变量是不会被修改的     
在函数内部修改全局变量的方法：使用关键字“global” 就可以在函数内部修改全局变量。（不建议这样做）    
2.在内部函数中需要修改外部函数的变量时，使用关键字“nonlocal”,道理和全局变量是一样的。      
```sh
def Fun1():
    x = 5
    def Fun2():
        nonlocal x
        x *= x
        return x
    return Fun2()
```
