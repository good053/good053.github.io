上篇文章介绍了黑盒测试，本篇文章则介绍与之相对的白盒测试。  
白盒测试又称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试。也就是说白盒测试的对象是程序代码本身，测试人员通过对代码语句测试，从中发现内部代码在算法、溢出、路径、条件等等中的缺点或者错误，进而加以修正。   
白盒测试常见的用例设计方法有：代码检查法、静态结构分析法、静态质量度量法、逻辑覆盖法、基本路径覆盖测试法、域测试、符号测试。

### 代码检查法

代码检查是对程序代码进行静态检查。传统的代码检查是通过人工阅读代码的方式，检查软件设计的正确性，用人脑模拟程序在计算机中的运行，仔细推敲、校验和核实程序每一步的执行结果，进而判断其执行逻辑、控制模型、算法和使用参数和数据的正确性。   
代码检查包括桌面检查、代码审查和走查等，主要检查代码和设计的一致性，代码对标准的遵循、可读性，代码逻辑表达的正确性，代码结构的合理性等方面；发现违背程序编写标准的问题，程序中不安全、不明确和模糊的部分，找出程序中不可移植部分、违背程序编程风格的内容，包括变量检查、命名和类型审查、程序逻辑审查、程序语法检查和程序结构检查等内容。   
代码检查方法：   
（1）桌面检查   
这是一种传统的检查方法，由程序员检查自己编写的程序。程序员在程序通过编译之后，对源程序代码进行分析、检验，并补充相关文档，目的是发现程序中的错误。由于程序员熟悉自己的程序及其程序设计风格，桌面检查由程序员自己进行可以节省很多的检查时间，但应避免主观片面性。   
（2）代码审查   
是由一组人通过阅读、讨论和争议对程序进行静态分析的过程，一般以小组会的方式进行。审查小组一般由若干程序员（包括程序代码的设计者）和测试人员组成。会前把设计规格说明书、控制流程图、程序文本及有关要求、规范等分发给小组成员，作为审查的依据。开会时程序作者朗读解释程序，其他人员则捕捉程序在结构、功能、编码风格等方面的问题。   
（3）代码走查   
代码走查就是针对代码，在假想的输入情况下，逐行的浏览代码，走查代码中潜在的缺陷并记录结果的过程。代码走查一般以小组会的形式进行，每组3-5人，与代码审查不同的是，走查要求与会者扮演计算机的角色让测试用例沿被测程序的逻辑运行，是在模拟动态测试；而代码审查更多的是静态测试。

### 静态结构分析法
 程序的结构形式是白盒测试的主要依据。在静态结构分析中，测试者通过使用测试工具分析程序源代码的系统结构、数据结构、内部控制逻辑等内部结构，生成函数调用关系图、模块控制流图、内部文件调用关系图、子程序表、宏和函数参数表等各类图形图标，可以清晰地标识整个软件系统的组成结构，使其便于阅读和理解，然后可以通过分析这些图标，检查软件是否存在缺陷或错误。   
 函数调用关系图是指通过应用程序中各函数之间的调用关系来展示系统的结构。通过查看函数调用关系图，可以检查函数之间的调用关系是否符合要求，是否存在递归调用，函数的调用层是否过深，是否存在独立的没有被调用的函数，从而可以发现系统是否存在结构缺陷，发现哪些函数是重要的，哪些是次要的，需要使用什么级别的覆盖要求等。   
 模块控制流图与程序流程图相类似，是由许多节点和连接节点的边组成的，其中一个节点代表一条语句或数条语句，边代表节点间控制流向，它显示了一个函数的内部逻辑结构。模块控制流图可以直观地反映出一个函数的内部逻辑结构，通过检查这些模块控制流图，能够很快发现软件的错误与缺陷
 
### 静态质量度量法
ISO/IEC 9126国际标准指出，软件的质量包括：功能性(FUNCTLONALITY)，可靠性(RELIABILITY)，可用性(USABILITY)，有效性(EFFICIENCY)，可维护性(MAINTAINABILITY)和轻便性(PORTABILITY)。以ISO/IEC 9126质量模型作为基础，我们可以构造质量度量模型，用于评估软件的各个方面。   
###### 质量度量模型   
该模型从上到下分为3层。   
质量因素（Factors）：与分类标准的计算方式相似，依据各分类标准取值组合权重方法来计算，依据结果将软件质量分为四个等级，与分类标准等级内容相同；对应ISO 9126质量模型的质量特性。    
分类标准（criteria）：分类标准对应ISO 9126质量模型的子特性。对某一软件质量分为不同的分类标准，每个分类标准由一系列度量规则组成，每个规则分配一个权重，每个分类标准的取值由规则的取值与权重值计算得出，依据结果将软件质量分为四个等级：   
 - 优秀（exceent）：符合本模型框加中的所有规则（可以接受）   
 - 良好（good）：未大量偏离模型框架中的规则（可以接受）   
 - 一般（fair）：违背了模型框架中的大量规则（可以接受）   
 - 较差（poor）：无法保障正常的软件可维护性（不可以接受）   

度量规则（Metrics）：使用代码行数、注释频度等参数度量软件各种行为属性。参数定义见下表：   

| 简称 | 名 称| 最小值 | 最大值 |
| --- | --- | --- | --- |
|PARA|参数数量（Number of function parameters）|0|5|
|PATH|路径数量（Number of paths	）|1|80|
|LEVL|级别数量（Number of levels）|0|4|
|DRCT_CALLS|直接调用的数量	（Number of direct calls）|0|7|
|RETU|	RETURN语句的数量（Number of RETURN statements）|0|1|
|NBCALLING|	调用者数量（Number of callers）|0|5|
|GOTO|	GOTO声明的数量（Number of GOTO statements）|0|0|
|VOCF|	词汇频率（Vocabulary frequency）|1|4|
|LVAR|	局部变量的数量（Number of local variables）|0|5|
|COMF|	评论频率（Comments frenquency）|0.2|无穷|
|AVGS|	声明的平均大小（Average size of statements）|1|9|
|STMT|	声明的数量（Number of statements）|1|50|
|VG|	环形数（VG）（Cyclomatic number(VG)）|1|10|
|IND_CALLS|	相对调用图调用路径的数量（Number of relative call graph call-paths）|1|30|
|TESTBTY|	相对调用图系统可测试性（Relative call graph System testability）|0|1|
|HYER_CPX|	相对调用图层次复杂性（Relative call graph Hierarchical complexity）|1|5|
|LEVELS|	相对调用图级别的数量（Number of relative call graph levels）|1|12|
|STRU_CPX|	相对调用图结构复杂性（Relative call graph Structural complexity）|0|3|
|DDP|	直流覆盖率（DC coverage rate）|0|100|
|IB|	SC覆盖率（SC coverage rate）|0|100|
|PPP|	程序到程序路径覆盖率（Procedure-to-Procedure Path coverage rate）|0|100|

### 逻辑覆盖法

逻辑覆盖是以程序内部的逻辑结构为基础的设计测试用例的技术。根据覆盖目标的不同和覆盖源程序语句的详尽程度，逻辑覆盖又可分为（几种逻辑覆盖标准发现错误的能力呈由弱至强的变化）：    
1. 语句覆盖(SC)
2. 判定覆盖(DC)
3. 条件覆盖(CC)
4. 条件/判定覆盖(CC)
5. 条件组合覆盖(MCC)
6. 修正判定条件覆盖(MCDC)
7. 点覆盖
8. 边覆盖
9. 路径覆盖

**语句覆盖**：是指选择足够的测试用例，使得运行这些测试用例时，被测程序的每一个语句至少执行一次，其覆盖标准无法发现判定中逻辑运算的错误。   
语句覆盖率的公式：语句覆盖率=被评价到的语句数量/可执行语句总数x100%   
语句覆盖的缺点：对程序执行逻辑的覆盖很低。 

**判定覆盖**：有时也称分支覆盖，就是指设计若干测试用例，运行被测程序，使得每个判定的取真分支和取假分支至少评价一次。   
判定覆盖的公式： 判定覆盖率=被评价到的判定分支个数/判定分支的总数X100%。   
判定路径覆盖率（DDP）=被评价到的判定路径数量/判定路径的总数X100%。   
判定覆盖的缺点：判定覆盖虽然把程序所有分支均覆盖到了，但其主要对整个表达式最终取值进行度量，忽略了表达式内部取值。   

**条件覆盖**：设计足够多的测试用例，运行被测程序，使得每一判定语句中每个逻辑条件的可能取值至少满足一次。                           条件覆盖率的公式：条件覆盖率=被评价到的条件取值的数量/条件取值的总数X100%。
条件覆盖的缺点：只考虑到每个判定语句中的每个表达式，没有考虑到各个条件分支（或者涉及不到全部分支），即不能够满足判定覆盖。   

**条件/判定覆盖**： 设计足够多的测试用例，使得判定中的每个条件的所有可能（真/假）至少出现一次，并且每个判定本身的判定结果也至少出现一次。   
判定条件覆盖率的公式： 条件判定覆盖率=被评价到的条件取值和判定分支的数量/（条件取值总数+判定分支总数）。   
评定条件覆盖的缺点：没有考虑单个判定对整体结果的影响，无法发现逻辑错误。   
**条件组合覆盖**：选择足够的测试用例，使得每个判定中条件的各种可能组合都至少出现一次。显然，满足“条件组合覆盖”的测试用例是一定满足“判定覆盖”、“条件覆盖”和“判定/条件覆盖”的。   
条件组合覆盖率的公式：条件组合覆盖率=被评价到的条件取值组合的数量/条件取值组合的总数。   
条件组合覆盖的缺点：判定语句较多时，条件组合值比较多。   

**修正判定条件覆盖**：MC/DC首先要求实现条件覆盖、判定覆盖，在此基础上，对于每一个条件C，要求存在符合以下条件的两次计算：
    1）条件C所在判定内的所有条件，除条件C外，其他条件的取值完全相同；
    2）条件C的取值相反；
    3）判定的计算结果相反。

核心意思是每个条件都要独立影响判定结果。为什么说“两次计算”，而不是“两个用例”呢？当循环中有判定时，一个用例下同一判定可能被计算多次，每次的条件值和判定值也可能不同，因此，一个用例就可能完成循环中判定的MC/DC。   
MC/DC是条件组合覆盖的子集。条件组合覆盖要求覆盖判定中所有条件取值的所有可能组合，需要大量的测试用例，实用性较差。MC/DC具有条件组合覆盖的优势，同时大幅减少用例数。满足MC/DC的用例数下界为条件数+1，上界为条件数的两倍，例如，判定中有三个条件，条件组合覆盖需要8个用例，而MC/DC需要的用例数为4至6个。如果判定中条件很多，用例数的差别将非常大，例如，判定中有10个条件，条件组合覆盖需要1024个用例，而MC/DC只需要11至20个用例。   

**路径覆盖**：MC/DC被称为“最严格的标准”，但这种说法是将条件组合覆盖和路径覆盖排除在外为基础的。MC/DC显然不如条件组合覆盖严格，但是条件组合覆盖需要太多用例，实际应用中难以做到，所以排除，那么，路径覆盖是否也难以做到？使用先进的工具，对于一般的代码，实现路径覆盖还是可能的。另外，路径代表了从函数入口到出口的所有可能的代码组合，这些组合会不会出问题？只有路径覆盖能发现，这与MC/DC侧重于判定内的条件的组合关系是完全不同的。

ＭC/DC与路径覆盖的侧重点不同，两者都有其优势和局限性，如果组合起来，优势互补，形成“MC/DC-路径覆盖”，就是真正意义上的“最严格的标准”了。有些程序，路径数量可能大得惊人，可用以下规则和方法减少路径数量：
 - 计算路径时，不考虑循环的次数，将循环结构视为循环体“至少执行一次”和“从不执行”两个分支；
 - 不考虑条件的计算结果只考虑判定的计算结果，条件间的组合关系由条件覆盖、C/DC和MC/DC负责；
 - 一个分支如果不可达，通过该分支的所有路径也不可达，可以让工具自动排除；
 - 当代码很复杂时，理想的处置方式是将部分代码独立为函数，如果做不到，可以让工具来模拟，即在逻辑结构图中，将部分代码临时屏蔽，被屏蔽的代码视为一个函数调用。交替屏蔽可以既减少路径数量，又保证路径覆盖的效果。

对于一般复杂度的代码，采用以上规则和方法后，路径数量和用例数量可以维持在一个现实可覆盖的的范围内。路径覆盖的主要缺陷是：不相关的逻辑块会组合出大量没有意义的路径。一个函数的路径，可能达到几万条甚至几百万条。如果路径超过100条，通常路径覆盖就没有意义了。对于一般企业来说，建议用MC/DC作为统一的覆盖标准，只有特别关键的代码，才要求完成“MC/DC-路径覆盖”。
 
路径覆盖要求设计足够多的测试用例，在白盒测试法中，覆盖程度最高的就是路径覆盖，因为其覆盖程序中所有可能的路径。对于比较简单的小程序来说，实现路径覆盖是可能的，但是如果程序中出现了多个判断和多个循环，可能的路径数目将会急剧增长，以致实现路径覆盖是几乎不可能的。

（未完待续……）

